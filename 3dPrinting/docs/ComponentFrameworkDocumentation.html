<head> <link rel="stylesheet" href="documentationStyles.css"/> <script src="http://code.jquery.com/jquery-latest.min.js"></script> <script src="expandableLists.js"></script> </head><body onload="setup();"> <div id="main"><div><h1>Documentation for Programmatic 3D Printing </h1> <h2>[AUTOGENERATED FROM MOCHA UNIT TESTS]</h2><h2>Author: Daniel Patterson</h2></div><div class="buttons"><a id="expandList">Expand All</a> <a id="collapseList">Collapse All</a> <a id="toggleCode" onclick="toggleCodeVisible();">Show test code</a></div>
    <section class="suite">
      <h1>Specification</h1>
      <dl>
        <dt>should behave like a Specification</dt>
        <dd><pre><code>shouldBehaveLikeSpecification(specification)</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>Shape</h1>
      <dl>
        <dt>should behave like a Shape</dt>
        <dd><pre><code>shouldBehaveLikeShape(shape)</code></pre></dd>
        <section class="suite">
          <h1>#getType</h1>
          <dl>
            <dt>should return &quot;Shape&quot;</dt>
            <dd><pre><code>shape.getType().should.equal('Shape')</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>distance to boundary functions</h1>
          <dl>
            <section class="suite">
              <h1>#getDistanceToRightBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>var message = &quot;getDistanceToRightBoundary() not implemented in Shape &quot; +
              &quot;base class&quot;
shape.getDistanceToRightBoundary.should.throw(message)</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToLeftBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>var message = &quot;getDistanceToLeftBoundary() not implemented in Shape &quot; +
              &quot;base class&quot;
shape.getDistanceToLeftBoundary.should.throw(message)</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToFrontBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>var message = &quot;getDistanceToFrontBoundary() not implemented in Shape &quot; +
              &quot;base class&quot;
shape.getDistanceToFrontBoundary.should.throw(message)</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToBackBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>var message = &quot;getDistanceToBackBoundary() not implemented in Shape &quot; +
              &quot;base class&quot;
shape.getDistanceToBackBoundary.should.throw(message)</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Component</h1>
      <dl>
        <dt>should behave like a Component</dt>
        <dd><pre><code>shouldBehaveLikeComponent(component)</code></pre></dd>
        <section class="suite">
          <h1>#getTypeName</h1>
          <dl>
            <dt>should return &quot;Component&quot;</dt>
            <dd><pre><code>component.getTypeName().should.equal('Component')</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>creation</h1>
          <dl>
            <dt>should create a Component with a unique ID</dt>
            <dd><pre><code>component.getID().should.not.equal(otherComponent.getID())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#isTouching</h1>
          <dl>
            <dt>should be false if the Components' bounding shapes do not intersect</dt>
            <dd><pre><code>otherComponent.getBoundingShape().setRadius(5)
component.isTouching(otherComponent).should.be.false</code></pre></dd>
            <dt>should be true if the Components' bounding shapes intersect</dt>
            <dd><pre><code>otherComponent.getBoundingShape().setRadius(50)
component.isTouching(otherComponent).should.be.true</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>PlaceableComponent</h1>
      <dl>
        <dt>should behave like a PlaceableComponent</dt>
        <dd><pre><code>function setupBoundaries(placeable) {
			placeable.getPlacementShape().setRadius(10)
		}
shouldBehaveLikePlaceableComponent(PlaceableComponent, 
			                                 setupBoundaries, 
			                                 Circle)</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>Point</h1>
      <dl>
        <section class="suite">
          <h1>#createFixedPoint</h1>
          <dl>
            <dt>should have a fixed x coordinate of 10</dt>
            <dd><pre><code>point.getX().getValue().should.equal(10)
point.getX().isRigid().should.be.true</code></pre></dd>
            <dt>should have a fixed y coordinate of 20</dt>
            <dd><pre><code>point.getY().getValue().should.equal(20)
point.getY().isRigid().should.be.true</code></pre></dd>
            <dt>should have a fixed z coordinate of 30</dt>
            <dd><pre><code>point.getZ().getValue().should.equal(30)
point.getZ().isRigid().should.be.true</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#createPoint</h1>
          <dl>
            <dt>should have an unfixed x coordinate</dt>
            <dd><pre><code>point.getX().isRigid().should.be.false</code></pre></dd>
            <dt>should have an unfixed y coordinate</dt>
            <dd><pre><code>point.getY().isRigid().should.be.false</code></pre></dd>
            <dt>should have an unfixed z coordinate</dt>
            <dd><pre><code>point.getZ().isRigid().should.be.false</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#isAtSameLocationAs</h1>
          <dl>
            <dt>should return true if the Points are co-located</dt>
            <dd><pre><code>otherPoint.setAt(x, y, z)
      point.isAtSameLocationAs(otherPoint).should.be.true</code></pre></dd>
            <dt>should return false if the Points are not co-located</dt>
            <dd><pre><code>otherPoint.setAt(x, y, z + 1)
      point.isAtSameLocationAs(otherPoint).should.be.false</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#fixAt</h1>
          <dl>
            <dt>should have a fixed x coordinate of 1</dt>
            <dd><pre><code>point.getX().getValue().should.equal(1)
point.getX().isRigid().should.be.true</code></pre></dd>
            <dt>should have a fixed y coordinate of 2</dt>
            <dd><pre><code>point.getY().getValue().should.equal(2)
point.getY().isRigid().should.be.true</code></pre></dd>
            <dt>should have a fixed z coordinate of 3</dt>
            <dd><pre><code>point.getZ().getValue().should.equal(3)
point.getZ().isRigid().should.be.true</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#setAt</h1>
          <dl>
            <dt>should have an unfixed x coordinate of 1</dt>
            <dd><pre><code>point.getX().getValue().should.equal(1)
point.getX().isRigid().should.be.false</code></pre></dd>
            <dt>should have an unfixed y coordinate of 2</dt>
            <dd><pre><code>point.getY().getValue().should.equal(2)
point.getY().isRigid().should.be.false</code></pre></dd>
            <dt>should have an unfixed z coordinate of 3</dt>
            <dd><pre><code>point.getZ().getValue().should.equal(3)
point.getZ().isRigid().should.be.false</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#offsetFrom</h1>
          <dl>
            <section class="suite">
              <h1>when the indpendent Point is set after the constraints are created</h1>
              <dl>
                <dt>should set the x coordinate of the dependent Point to the combination of the x offset and the indpendent x coordinate</dt>
                <dd><pre><code>point.getX().getValue().should.equal(offsets[0] 
	                                   + otherPoint.getX().getValue())</code></pre></dd>
                <dt>should set the y coordinate of the dependent Point to the combination of the y offset and the indpendent y coordinate</dt>
                <dd><pre><code>point.getY().getValue().should.equal(offsets[1] 
	                                   + otherPoint.getY().getValue())</code></pre></dd>
                <dt>should set the z coordinate of the dependent Point to the combination of the z offset and the indpendent z coordinate</dt>
                <dd><pre><code>point.getZ().getValue().should.equal(offsets[2] 
	                                   + otherPoint.getZ().getValue())</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>when the indpendent Point is set before the constraints are created</h1>
              <dl>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#isFullyDefined</h1>
          <dl>
            <dt>should be false if not all coordinates of the Point have been set</dt>
            <dd><pre><code>point.isFullyDefined().should.be.false</code></pre></dd>
            <dt>should be true if all coordinates of the Point have been set</dt>
            <dd><pre><code>point.setAt(1, 2, 3)
point.isFullyDefined().should.be.true</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#isNotFullyDefined</h1>
          <dl>
            <dt>should be true if not all coordinates of the Point have been set</dt>
            <dd><pre><code>point.isNotFullyDefined().should.be.true</code></pre></dd>
            <dt>should be false if all coordinates of the Point have been set</dt>
            <dd><pre><code>point.setAt(1, 2, 3)
point.isNotFullyDefined().should.be.false</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>sameAs</h1>
          <dl>
            <dt>should have all its values set</dt>
            <dd><pre><code>point.isFullyDefined().should.be.true</code></pre></dd>
            <dt>should have the same coordinates as the indpendent Point</dt>
            <dd><pre><code>point.isAtSameLocationAs(otherPoint).should.be.true</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#samePointOnAxes</h1>
          <dl>
            <dt>should have all its values set</dt>
            <dd><pre><code>point.isFullyDefined().should.be.true</code></pre></dd>
            <dt>should have the same coordinates as the indpendent Point</dt>
            <dd><pre><code>point.isAtSameLocationAs(otherPoint).should.be.true</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#offsetOnAxis</h1>
          <dl>
            <dt>should have an x coordinate offset from the independent Point</dt>
            <dd><pre><code>point.getX().getValue().should.equal(otherPoint.getX().getValue() + offset)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>Point.getAxesNames</h1>
          <dl>
            <dt>should return an array of the capitalised axes names</dt>
            <dd><pre><code>Point.getAxesNames().should.eql(['X', 'Y', 'Z'])</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>Point.getAxesNamesWithout</h1>
          <dl>
            <dt>should return the array of axes names without the passed in argument</dt>
            <dd><pre><code>Point.getAxesNamesWithout('X').should.eql(['Y', 'Z'])</code></pre></dd>
            <dt>should ignore values that are not axes names</dt>
            <dd><pre><code>Point.getAxesNamesWithout('b').should.eql(['X', 'Y', 'Z'])</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>SameAsConstraint</h1>
      <dl>
        <dt>should constrain a dependent value to be equal to the independent value</dt>
        <dd><pre><code>new constraints.SameAsConstraint(leftValue, rightValue)
rightValue.setValue(10)
leftValue.getValue().should.equal(rightValue.getValue())</code></pre></dd>
        <dt>should be one way - a change in the dependent value should not change the independent value</dt>
        <dd><pre><code>new constraints.SameAsConstraint(leftValue, rightValue)
rightValue.setValue(15)
leftValue.setValue(10)
leftValue.getValue().should.not.equal(rightValue.getValue())</code></pre></dd>
        <section class="suite">
          <h1>#isSatisfied</h1>
          <dl>
            <dt>should return true if both values have the same stored value</dt>
            <dd><pre><code>rightValue.setValue(10)
leftValue.setValue(10)
var sameAs = new constraints.SameAsConstraint(leftValue, rightValue)
sameAs.isSatisfied().should.be.true</code></pre></dd>
            <dt>should return false if the values are different</dt>
            <dd><pre><code>rightValue.setValue(10)
leftValue.setValue(12)
var sameAs = new constraints.SameAsConstraint(leftValue, rightValue)
sameAs.isSatisfied().should.be.false</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>OffsetByConstantConstraint</h1>
      <dl>
        <dt>should constrain a dependent value to be a constant distance from the independent value</dt>
        <dd><pre><code>new constraints.OffsetByConstantConstraint(leftValue, rightValue, 15)
rightValue.setValue(10)
leftValue.getValue().should.equal(rightValue.getValue() + 15)</code></pre></dd>
        <dt>should be one way - a change in the dependent value should not change the independent value</dt>
        <dd><pre><code>new constraints.OffsetByConstantConstraint(leftValue, rightValue, 15)
rightValue.setValue(15)
leftValue.setValue(10)
		leftValue.getValue().should.not.equal(rightValue.getValue() + 15)</code></pre></dd>
        <dt>should not be satisfied if the left value is not set</dt>
        <dd><pre><code>constraint = new constraints.OffsetByConstantConstraint(leftValue, 
	                                                      rightValue, 
	                                                      15)
constraint.isSatisfied().should.be.false</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>ScaledByConstantConstraint</h1>
      <dl>
        <dt>should constrain a dependent value to be a constant factor larger than the independent value</dt>
        <dd><pre><code>new constraints.ScaledByConstantConstraint(leftValue, rightValue, 1.5)
rightValue.setValue(10)
leftValue.getValue().should.equal(rightValue.getValue() * 1.5)</code></pre></dd>
        <dt>should be one way - a change in the dependent value should not change the independent value</dt>
        <dd><pre><code>new constraints.ScaledByConstantConstraint(leftValue, rightValue, 15)
rightValue.setValue(15)
leftValue.setValue(10)
		leftValue.getValue().should.not.equal(rightValue.getValue() * 15)</code></pre></dd>
        <dt>should not be satisfied if the left value is not set</dt>
        <dd><pre><code>constraint = new constraints.ScaledByConstantConstraint(leftValue, 
	                                                      rightValue, 
	                                                      1.5)
constraint.isSatisfied().should.be.false</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>Circle</h1>
      <dl>
        <dt>should behave like a Shape</dt>
        <dd><pre><code>ShapeTest.shouldBehaveLikeShape(circle)</code></pre></dd>
        <section class="suite">
          <h1>#setRadius</h1>
          <dl>
            <dt>should set the radius of the Circle</dt>
            <dd><pre><code>circle.getRadius().getValue().should.equal(10)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#getDiameter</h1>
          <dl>
            <dt>should be twice the radius</dt>
            <dd><pre><code>circle.getDiameter().getValue().should.equal(2 * radius)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#toSpecification</h1>
          <dl>
            <dt>should not be possible if the radius is not set</dt>
            <dd><pre><code>circle.toSpecification.should.throw(&quot;Radius not set&quot;)</code></pre></dd>
            <dt>should not be possible if the centre is not set even if the radius is</dt>
            <dd><pre><code>circle.setRadius(1)
circle.toSpecification.should.throw(&quot;Centre not fully defined&quot;)</code></pre></dd>
            <dt>should be possible if both the centre and radius are set</dt>
            <dd><pre><code>(function() {
	setRadiusAndCentre()
	circle.toSpecification()
}).should.not.throw()</code></pre></dd>
            <section class="suite">
              <h1>the returned CircleSpecification</h1>
              <dl>
                <dt>should behave like a CircleSpecification</dt>
                <dd><pre><code>CircleSpecificationTest.testCircleSpecification(circleSpec, circle)</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>distance to boundary functions</h1>
          <dl>
            <section class="suite">
              <h1>#getDistanceToRightBoundary</h1>
              <dl>
                <dt>should return the value of the radius</dt>
                <dd><pre><code>circle.getDistanceToRightBoundary().should.equal(radius)</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToLeftBoundary</h1>
              <dl>
                <dt>should return the negative of the value of the radius</dt>
                <dd><pre><code>circle.getDistanceToLeftBoundary().should.equal(-radius)</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToFrontBoundary</h1>
              <dl>
                <dt>should return the value of the radius</dt>
                <dd><pre><code>circle.getDistanceToFrontBoundary().should.equal(radius)</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToBackBoundary</h1>
              <dl>
                <dt>should return the negative of the value of the radius</dt>
                <dd><pre><code>circle.getDistanceToBackBoundary().should.equal(-radius)</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Test more complex constraint networks</h1>
      <dl>
        <section class="suite">
          <h1>Two values depending on the same value</h1>
          <dl>
            <dt>should set both dependent values to the stored value of the independent value</dt>
            <dd><pre><code>new constraints.SameAsConstraint(thirdValue, firstValue)
new constraints.SameAsConstraint(secondValue, firstValue)
firstValue.setValue(10)
secondValue.getValue().should.equal(firstValue.getValue())
thirdValue.getValue().should.equal(firstValue.getValue())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>A chain of equality dependencies</h1>
          <dl>
            <dt>should set all the values to be equal</dt>
            <dd><pre><code>new constraints.SameAsConstraint(thirdValue, secondValue)
new constraints.SameAsConstraint(secondValue, firstValue)
firstValue.setValue(10)
secondValue.getValue().should.equal(firstValue.getValue())
thirdValue.getValue().should.equal(secondValue.getValue())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>A chain of dependencies, an equality and a constant offset</h1>
          <dl>
            <dt>should set the second value to be equal to the first and the third to be a constant from the second</dt>
            <dd><pre><code>new constraints.OffsetByConstantConstraint(thirdValue, secondValue, 15)
			new constraints.SameAsConstraint(secondValue, firstValue)
			firstValue.setValue(10)
			secondValue.getValue().should.equal(firstValue.getValue())
			thirdValue.getValue().should.equal(secondValue.getValue() + 15)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>A chain of dependencies, an equality and a constant offset</h1>
          <dl>
            <dt>should set the second value to be equal to the first and the third to be a the offset from the second</dt>
            <dd><pre><code>new constraints.OffsetByConstantConstraint(thirdValue, secondValue, 15)
			new constraints.SameAsConstraint(secondValue, firstValue)
			firstValue.setValue(10)
			secondValue.getValue().should.equal(firstValue.getValue())
			thirdValue.getValue().should.equal(10 + 15)</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>ComponentGroup</h1>
      <dl>
        <dt>should behave like a PlaceableComponentGroup</dt>
        <dd><pre><code>shouldBehaveLikeComponentGroup(group)</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>Line</h1>
      <dl>
        <section class="suite">
          <h1>construction</h1>
          <dl>
            <dt>should not be possible without two Points as arguments</dt>
            <dd><pre><code>(function(){
	new Line()
}).should.throw(&quot;Two Points required&quot;)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#getCentre</h1>
          <dl>
            <dt>should return a Point</dt>
            <dd><pre><code>line.getCentre().should.be.an.instanceof(Point)</code></pre></dd>
            <section class="suite">
              <h1>the returned Point</h1>
              <dl>
                <dt>should have an x coordinate at half the distance between the two Points</dt>
                <dd><pre><code>centre.getX().getValue().should.equal(startX + xDifference / 2)</code></pre></dd>
                <dt>should have a y coordinate at half the distance between the two Points</dt>
                <dd><pre><code>centre.getY().getValue().should.equal(startY + yDifference / 2)</code></pre></dd>
                <dt>should have a z coordinate at half the distance between the two Points</dt>
                <dd><pre><code>centre.getZ().getValue().should.equal(startZ + zDifference / 2)</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#getWidth</h1>
          <dl>
            <dt>should have a default value of 1</dt>
            <dd><pre><code>line.getWidth().should.equal(1)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#getLength</h1>
          <dl>
            <dt>should be the hypotenuse of the triangle defined by the x and y differences between the Points</dt>
            <dd><pre><code>var length = Math.sqrt(xDifference * xDifference 
					             + yDifference * yDifference
					             + zDifference * zDifference)
line.getLength().should.equal(length)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#getAngleInRadians</h1>
          <dl>
            <dt>should return the angle this line makes with the x axis</dt>
            <dd><pre><code>var angle = Math.atan2(yDifference, xDifference)
line.getAngleInRadians().should.be.approximately(angle, 0.001)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#toSpecification</h1>
          <dl>
            <section class="suite">
              <h1>the returned LineSpecification</h1>
              <dl>
                <dt>should behave like a LineSpecification</dt>
                <dd><pre><code>LineSpecificationTest.testLineSpecification(lineSpec, line)</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>ConstrainableValue</h1>
      <dl>
        <section class="suite">
          <h1>#setValue</h1>
          <dl>
            <dt>should change the stored value</dt>
            <dd><pre><code>value.setValue(10)
value.getValue().should.equal(10)</code></pre></dd>
            <dt>should throw an exception if the value is rigid</dt>
            <dd><pre><code>(function() { 
	value.fixValue(0)
	value.setValue(10)
}).should.throw()</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#fixValue</h1>
          <dl>
            <dt>should change the stored value</dt>
            <dd><pre><code>value.getValue().should.equal(10)</code></pre></dd>
            <dt>should make the value rigid</dt>
            <dd><pre><code>value.isRigid().should.be.true</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#unfixValue</h1>
          <dl>
            <dt>should not change the stored value</dt>
            <dd><pre><code>value.getValue().should.equal(10)</code></pre></dd>
            <dt>should stop the value from being rigid</dt>
            <dd><pre><code>value.isRigid().should.be.false</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#isSet</h1>
          <dl>
            <dt>should return false if the stored value has not been set</dt>
            <dd><pre><code>value.isSet().should.be.false</code></pre></dd>
            <dt>should return true if the stored value has been set</dt>
            <dd><pre><code>value.setValue(10)
value.isSet().should.be.true</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#isFlexible</h1>
          <dl>
            <dt>should return true if the value is not rigid</dt>
            <dd><pre><code>value.isFlexible().should.be.true</code></pre></dd>
            <dt>should return false if the value is rigid</dt>
            <dd><pre><code>value.fixValue(10)
value.isFlexible().should.be.false</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>Two-way Constraint functions</h1>
          <dl>
            <section class="suite">
              <h1>#sameAs</h1>
              <dl>
                <dt>should add a new Constraint to the ConstrainableValue </dt>
                <dd><pre><code>var numberOfConstraintsBefore = value.getConstraints().length
value.sameAs(anotherValue)
value.getConstraints().length.should.equal(numberOfConstraintsBefore + 1)</code></pre></dd>
                <dt>should constrain this value to the same value as the other value</dt>
                <dd><pre><code>value.sameAs(anotherValue)
anotherValue.setValue(10)
value.getValue().should.equal(anotherValue.getValue())</code></pre></dd>
                <dt>should constrain the other value to be the same as this value if this value is set first</dt>
                <dd><pre><code>value.sameAs(anotherValue)
value.setValue(10)
value.getValue().should.equal(anotherValue.getValue())
value.getValue().should.equal(10)</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#offsetByConstant</h1>
              <dl>
                <dt>should add a new Constraint to the ConstrainableValue </dt>
                <dd><pre><code>var numberOfConstraintsBefore = value.getConstraints().length
value.offsetByConstant(anotherValue, 15)
value.getConstraints().length.should.equal(numberOfConstraintsBefore + 1)</code></pre></dd>
                <dt>should constrain this value to be a constant offset from the other value</dt>
                <dd><pre><code>value.offsetByConstant(anotherValue, 15)
anotherValue.setValue(10)
        value.getValue().should.equal(anotherValue.getValue() + 15)</code></pre></dd>
                <dt>should constrain the other value to be a constant offset from this value if this value is set first</dt>
                <dd><pre><code>value.offsetByConstant(anotherValue, 15)
value.setValue(10)
value.getValue().should.equal(anotherValue.getValue() + 15)
anotherValue.getValue().should.equal(value.getValue() - 15)</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#scaledByConstant</h1>
              <dl>
                <dt>should add a new Constraint to the ConstrainableValue </dt>
                <dd><pre><code>var numberOfConstraintsBefore = value.getConstraints().length
value.scaledByConstant(anotherValue, 1.5)
value.getConstraints().length.should.equal(numberOfConstraintsBefore + 1)</code></pre></dd>
                <dt>should constrain this value to be a constant factor larger than the other value</dt>
                <dd><pre><code>value.scaledByConstant(anotherValue, 1.5)
anotherValue.setValue(10)
        value.getValue().should.equal(anotherValue.getValue() * 1.5)</code></pre></dd>
                <dt>should constrain the other value to be a constant factor smaller than this value if this value is set first</dt>
                <dd><pre><code>value.scaledByConstant(anotherValue, 15)
value.setValue(10)
value.getValue().should.equal(anotherValue.getValue() *  15)
anotherValue.getValue().should.be.approximately(value.getValue() /  15, 
	                                              0.001)</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>SpecificationWriter</h1>
      <dl>
        <section class="suite">
          <h1>#addComponent</h1>
          <dl>
            <dt>should add a new Specification to the writer</dt>
            <dd><pre><code>writer.getSpecifications().length.should.equal(0)
writer.addComponent(component)
writer.getSpecifications().length.should.equal(1)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#addComponentGroup</h1>
          <dl>
            <section class="suite">
              <h1>when the Components do not overlap</h1>
              <dl>
                <dt>should add two ComponentSpecifications to the writer</dt>
                <dd><pre><code>writer.getSpecifications().length.should.equal(2)</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>when the Components do overlap</h1>
              <dl>
                <dt>should not be possible</dt>
                <dd><pre><code>(function() {
	writer.addComponentGroup(group)
}).should.throw()</code></pre></dd>
                <section class="suite">
                  <h1>the error message generated</h1>
                  <dl>
                    <dt>should contain a string representation of the overlapping gears</dt>
                    <dd><pre><code>for (var i = overlappingComponents.length - 1; i &gt;= 0; i--) {
	errorMessage.should.contain(overlappingComponents[i].toString())
};</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#writeSpecificationToFile</h1>
          <dl>
            <section class="suite">
              <h1>the generated Main file</h1>
              <dl>
                <dt>should write to the file ../3dDrawer/main.jscad</dt>
                <dd><pre><code>fs.exists(mainFile, function(exists) {
	exists.should.be.true
})</code></pre></dd>
                <dt>should include a header explaining that the file is autogenerated</dt>
                <dd><pre><code>var infoHeader = '* [GENERATED FILE]'
fileContents.should.contain(infoHeader)</code></pre></dd>
                <dt>should include the contents of the static parameter file</dt>
                <dd><pre><code>var parameterDefinitions = fs.readFileSync(paramFile, 'utf8')
fileContents.should.contain(parameterDefinitions)</code></pre></dd>
                <dt>should contain a parameter definiton for shown components</dt>
                <dd><pre><code>fileContents.should.contain(&quot;Show: &quot;)</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>the generated Specification file</h1>
              <dl>
                <dt>should write to the file ../3dDrawer/Specification.jscad</dt>
                <dd><pre><code>fs.exists(specFile, function(exists) {
	exists.should.be.true
})</code></pre></dd>
                <dt>should include a header explaining that the file is autogenerated</dt>
                <dd><pre><code>var infoHeader = '* [GENERATED FILE]'
fileContents.should.contain(infoHeader)</code></pre></dd>
                <dt>should include a header to allow the file to be used as an OpenJSCAD library</dt>
                <dd><pre><code>var libraryHeader = 'Specification = function() {};\n\n'
fileContents.should.contain(libraryHeader)</code></pre></dd>
                <dt>should contain a prefix to allow OpenJSCAD access to the array of Specifications</dt>
                <dd><pre><code>var componentsPrefix = 'Specification.components = ['
fileContents.should.contain(componentsPrefix)</code></pre></dd>
                <dt>should contain a suffix for the array of ComponentSpecifications so that it is well-formed OpenJSCAD</dt>
                <dd><pre><code>fileContents.should.contain('];')</code></pre></dd>
                <section class="suite">
                  <h1>with two ComponentSpecifications added</h1>
                  <dl>
                    <dt>should contain a pretty-printed JSON String for both ComponentSpecifications in an array</dt>
                    <dd><pre><code>var array = [component.toSpecification(), 
 	           otherComponent.toSpecification()]
fileContents.should.contain(JSON.stringify(array, null, 2))</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>with a ComponentGroup added</h1>
              <dl>
                <dt>should contain a pretty-printed JSON String for all Specifications in an array</dt>
                <dd><pre><code>fileContents.should.contain(arrayString)</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from Specification</h1>
      <dl>
        <section class="suite">
          <h1>#addSpecification</h1>
          <dl>
            <dt>should have the same properties as the added Specification</dt>
            <dd><pre><code>specification.should.have.property('secondTestProperty', 'second')</code></pre></dd>
            <dt>should still have its original properties</dt>
            <dd><pre><code>specification.should.have.property('firstTestProperty', 'first')</code></pre></dd>
            <section class="suite">
              <h1>when the added Specification has the same property as the original property but with a different value</h1>
              <dl>
                <dt>should use the added Specification's value</dt>
                <dd><pre><code>specification.firstTestProperty.should.equal('different')</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from Shape</h1>
      <dl>
        <section class="suite">
          <h1>#setCentre</h1>
          <dl>
            <dt>should have an x coordinate of 1</dt>
            <dd><pre><code>shape.getCentre().getX().getValue().should.equal(centreX)</code></pre></dd>
            <dt>should have a y coordinate of 2</dt>
            <dd><pre><code>shape.getCentre().getY().getValue().should.equal(centreY)</code></pre></dd>
            <dt>should have a z coordinate of 3</dt>
            <dd><pre><code>shape.getCentre().getZ().getValue().should.equal(centreZ)</code></pre></dd>
            <dt>should not have exactly the same Point as its centre</dt>
            <dd><pre><code>shape.getCentre().should.not.equal(point)</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from Component</h1>
      <dl>
        <section class="suite">
          <h1>#getBoundingShape</h1>
          <dl>
            <dt>should return a Shape</dt>
            <dd><pre><code>ShapeTest.shouldBehaveLikeShape(component.getBoundingShape())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#getCentre</h1>
          <dl>
            <dt>should return a Point</dt>
            <dd><pre><code>component.getCentre().should.be.an.instanceOf(Point)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#setCentre</h1>
          <dl>
            <dt>should set the centre of the Component to have the same coordinates as the passed-in Point</dt>
            <dd><pre><code>component.getCentre().isAtSameLocationAs(point).should.be.true</code></pre></dd>
            <dt>should not have exactly the same Point as its centre</dt>
            <dd><pre><code>component.getCentre().should.not.equal(point)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#toString</h1>
          <dl>
            <dt>should return a string</dt>
            <dd><pre><code>component.toString().should.be.type('string')</code></pre></dd>
            <section class="suite">
              <h1>the returned string</h1>
              <dl>
                <dt>should contain the id</dt>
                <dd><pre><code>string.should.contain('ID: ' + id)</code></pre></dd>
                <dt>should contain the centre point</dt>
                <dd><pre><code>string.should.contain('Centre point: (' + centreX + ', ' + centreY 
	                    + ', ' + centreZ + ')')</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#toSpecification</h1>
          <dl>
            <dt>should not be possible if the centre Point is not fully defined</dt>
            <dd><pre><code>component.toSpecification.should.throw()</code></pre></dd>
            <dt>should be possible if the centre Point is fully defined </dt>
            <dd><pre><code>(function() {
							fixCentre()
							component.toSpecification()
						}).should.not.throw()</code></pre></dd>
            <section class="suite">
              <h1>the returned ComponentSpecification</h1>
              <dl>
                <dt>should behave like a ComponentSpecification derived from the Component</dt>
                <dd><pre><code>ComponentSpecificationTest.testComponentSpecification(componentSpec,
	                                                    component)</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from PlaceableComponent</h1>
      <dl>
        <dt>should behave like a Component</dt>
        <dd><pre><code>ComponentTest.shouldBehaveLikeComponent(placeable)</code></pre></dd>
        <section class="suite">
          <h1>#getPlacementShape</h1>
          <dl>
            <dt>should return the Shape to be used to define how the PlaceableComponent can be placed beside other PlaceableComponents</dt>
            <dd><pre><code>ShapeTest.shouldBehaveLikeShape(placeable.getPlacementShape())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#placeOnRightOf</h1>
          <dl>
            <section class="suite">
              <h1>the first Placeable</h1>
              <dl>
                <dt>should have its centre set when the second Placeable's centre is set</dt>
                <dd><pre><code>firstPlaceable.getCentre().isFullyDefined().should.be.true</code></pre></dd>
                <dt>should be centred to the Right of the second Placeable by a distance of the sum of their distances to their boundaries</dt>
                <dd><pre><code>var firstPlaceableCoordinate = firstPlaceable.getCentre()[getAxis]().getValue()
var secondPlaceableCoordinate = secondPlaceable.getCentre()[getAxis]().getValue()


var firstPlacementShape = firstPlaceable.getPlacementShape()
var secondPlacementShape = secondPlaceable.getPlacementShape()
var firstDistance = firstPlacementShape[getFirstDistance]()
var secondDistance = secondPlacementShape[getSecondDistance]()

var offset = secondDistance - firstDistance
firstPlaceableCoordinate.should.equal(secondPlaceableCoordinate + offset)</code></pre></dd>
                <section class="suite">
                  <h1>#getAdjacentComponents</h1>
                  <dl>
                    <dt>should return an array containing the second Placeable</dt>
                    <dd><pre><code>firstPlaceable.getAdjacentComponents().should.contain(secondPlaceable)</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>the second Placeable</h1>
              <dl>
                <section class="suite">
                  <h1>#getAdjacentComponents</h1>
                  <dl>
                    <dt>should return an array containing the first Placeable</dt>
                    <dd><pre><code>secondPlaceable.getAdjacentComponents().should.contain(firstPlaceable)</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#placeOnLeftOf</h1>
          <dl>
            <section class="suite">
              <h1>the first Placeable</h1>
              <dl>
                <dt>should have its centre set when the second Placeable's centre is set</dt>
                <dd><pre><code>firstPlaceable.getCentre().isFullyDefined().should.be.true</code></pre></dd>
                <dt>should be centred to the Left of the second Placeable by a distance of the sum of their distances to their boundaries</dt>
                <dd><pre><code>var firstPlaceableCoordinate = firstPlaceable.getCentre()[getAxis]().getValue()
var secondPlaceableCoordinate = secondPlaceable.getCentre()[getAxis]().getValue()


var firstPlacementShape = firstPlaceable.getPlacementShape()
var secondPlacementShape = secondPlaceable.getPlacementShape()
var firstDistance = firstPlacementShape[getFirstDistance]()
var secondDistance = secondPlacementShape[getSecondDistance]()

var offset = secondDistance - firstDistance
firstPlaceableCoordinate.should.equal(secondPlaceableCoordinate + offset)</code></pre></dd>
                <section class="suite">
                  <h1>#getAdjacentComponents</h1>
                  <dl>
                    <dt>should return an array containing the second Placeable</dt>
                    <dd><pre><code>firstPlaceable.getAdjacentComponents().should.contain(secondPlaceable)</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>the second Placeable</h1>
              <dl>
                <section class="suite">
                  <h1>#getAdjacentComponents</h1>
                  <dl>
                    <dt>should return an array containing the first Placeable</dt>
                    <dd><pre><code>secondPlaceable.getAdjacentComponents().should.contain(firstPlaceable)</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#placeAtBackOf</h1>
          <dl>
            <section class="suite">
              <h1>the first Placeable</h1>
              <dl>
                <dt>should have its centre set when the second Placeable's centre is set</dt>
                <dd><pre><code>firstPlaceable.getCentre().isFullyDefined().should.be.true</code></pre></dd>
                <dt>should be centred to the Back of the second Placeable by a distance of the sum of their distances to their boundaries</dt>
                <dd><pre><code>var firstPlaceableCoordinate = firstPlaceable.getCentre()[getAxis]().getValue()
var secondPlaceableCoordinate = secondPlaceable.getCentre()[getAxis]().getValue()


var firstPlacementShape = firstPlaceable.getPlacementShape()
var secondPlacementShape = secondPlaceable.getPlacementShape()
var firstDistance = firstPlacementShape[getFirstDistance]()
var secondDistance = secondPlacementShape[getSecondDistance]()

var offset = secondDistance - firstDistance
firstPlaceableCoordinate.should.equal(secondPlaceableCoordinate + offset)</code></pre></dd>
                <section class="suite">
                  <h1>#getAdjacentComponents</h1>
                  <dl>
                    <dt>should return an array containing the second Placeable</dt>
                    <dd><pre><code>firstPlaceable.getAdjacentComponents().should.contain(secondPlaceable)</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>the second Placeable</h1>
              <dl>
                <section class="suite">
                  <h1>#getAdjacentComponents</h1>
                  <dl>
                    <dt>should return an array containing the first Placeable</dt>
                    <dd><pre><code>secondPlaceable.getAdjacentComponents().should.contain(firstPlaceable)</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#placeAtFrontOf</h1>
          <dl>
            <section class="suite">
              <h1>the first Placeable</h1>
              <dl>
                <dt>should have its centre set when the second Placeable's centre is set</dt>
                <dd><pre><code>firstPlaceable.getCentre().isFullyDefined().should.be.true</code></pre></dd>
                <dt>should be centred to the Front of the second Placeable by a distance of the sum of their distances to their boundaries</dt>
                <dd><pre><code>var firstPlaceableCoordinate = firstPlaceable.getCentre()[getAxis]().getValue()
var secondPlaceableCoordinate = secondPlaceable.getCentre()[getAxis]().getValue()


var firstPlacementShape = firstPlaceable.getPlacementShape()
var secondPlacementShape = secondPlaceable.getPlacementShape()
var firstDistance = firstPlacementShape[getFirstDistance]()
var secondDistance = secondPlacementShape[getSecondDistance]()

var offset = secondDistance - firstDistance
firstPlaceableCoordinate.should.equal(secondPlaceableCoordinate + offset)</code></pre></dd>
                <section class="suite">
                  <h1>#getAdjacentComponents</h1>
                  <dl>
                    <dt>should return an array containing the second Placeable</dt>
                    <dd><pre><code>firstPlaceable.getAdjacentComponents().should.contain(secondPlaceable)</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>the second Placeable</h1>
              <dl>
                <section class="suite">
                  <h1>#getAdjacentComponents</h1>
                  <dl>
                    <dt>should return an array containing the first Placeable</dt>
                    <dd><pre><code>secondPlaceable.getAdjacentComponents().should.contain(firstPlaceable)</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from Shape</h1>
      <dl>
        <section class="suite">
          <h1>#setCentre</h1>
          <dl>
            <dt>should have an x coordinate of 1</dt>
            <dd><pre><code>shape.getCentre().getX().getValue().should.equal(centreX)</code></pre></dd>
            <dt>should have a y coordinate of 2</dt>
            <dd><pre><code>shape.getCentre().getY().getValue().should.equal(centreY)</code></pre></dd>
            <dt>should have a z coordinate of 3</dt>
            <dd><pre><code>shape.getCentre().getZ().getValue().should.equal(centreZ)</code></pre></dd>
            <dt>should not have exactly the same Point as its centre</dt>
            <dd><pre><code>shape.getCentre().should.not.equal(point)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>distance to boundary functions</h1>
          <dl>
            <section class="suite">
              <h1>#getDistanceToRightBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToRightBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToLeftBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToLeftBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToFrontBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToFrontBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToBackBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToBackBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#isAdjacentTo</h1>
          <dl>
            <dt>should return false if the Circle is not touching the Shape</dt>
            <dd><pre><code>point.setAt(centreX - 100, centreY, centreZ)
circle.setCentre(point)
shape.isAdjacentTo(circle).should.be.false</code></pre></dd>
            <dt>should return true if the Circle is to it's left</dt>
            <dd><pre><code>point.setAt(centreX - 1, centreY, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
            <dt>should return true if the Circle is to it's right</dt>
            <dd><pre><code>point.setAt(centreX + 1, centreY, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
            <dt>should return true if the Circle is to it's front</dt>
            <dd><pre><code>point.setAt(centreX, centreY + 1, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
            <dt>should return true if the Circle is to it's back</dt>
            <dd><pre><code>point.setAt(centreX, centreY - 1, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>CircleSpecification</h1>
      <dl>
        <dt>should have the same radius as the Circle that created it</dt>
        <dd><pre><code>circleSpec.radius.should.equal(circle.getRadius().getValue())</code></pre></dd>
        <dt>should behave like a Specification</dt>
        <dd><pre><code>SpecificationTest.shouldBehaveLikeSpecification(circleSpec)</code></pre></dd>
        <dt>should have the same centre x coordinate as the Circle that created it</dt>
        <dd><pre><code>circleSpec.centreX.should.equal(circle.getCentre().getX().getValue())</code></pre></dd>
        <dt>should have the same centre y coordinate as the Circle that created it</dt>
        <dd><pre><code>circleSpec.centreY.should.equal(circle.getCentre().getY().getValue())</code></pre></dd>
        <dt>should have the same centre z coordinate as the Circle that created it</dt>
        <dd><pre><code>circleSpec.centreZ.should.equal(circle.getCentre().getZ().getValue())</code></pre></dd>
        <dt>should have the type property of &quot;Circle&quot;</dt>
        <dd><pre><code>circleSpec.type.should.equal(&quot;Circle&quot;)</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from PlaceableComponentGroup</h1>
      <dl>
        <section class="suite">
          <h1>#addComponent</h1>
          <dl>
            <dt>should increase the number of Components in the PlaceableComponentGroup</dt>
            <dd><pre><code>group.getSize().should.equal(0)
group.addComponent(component)
group.getSize().should.equal(1)</code></pre></dd>
            <dt>should contain the Components that were added</dt>
            <dd><pre><code>group.addComponent(component)
group.getComponents().should.contain(component)</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>LineSpecification</h1>
      <dl>
        <dt>should behave like a Specification</dt>
        <dd><pre><code>SpecificationTest.shouldBehaveLikeSpecification(lineSpec)</code></pre></dd>
        <dt>should have the same length as the Line that created it</dt>
        <dd><pre><code>lineSpec.length.should.equal(line.getLength())</code></pre></dd>
        <dt>should have the same angle as the Line that created it</dt>
        <dd><pre><code>lineSpec.angleInRadians.should.equal(line.getAngleInRadians())</code></pre></dd>
        <dt>should have the same centre x coordinate as the Line that created it</dt>
        <dd><pre><code>lineSpec.centreX.should.equal(line.getCentre().getX().getValue())</code></pre></dd>
        <dt>should have the same centre y coordinate as the Line that created it</dt>
        <dd><pre><code>lineSpec.centreY.should.equal(line.getCentre().getY().getValue())</code></pre></dd>
        <dt>should have the same centre z coordinate as the Line that created it</dt>
        <dd><pre><code>lineSpec.centreZ.should.equal(line.getCentre().getZ().getValue())</code></pre></dd>
        <dt>should have the same width as the Line that created it</dt>
        <dd><pre><code>lineSpec.width.should.equal(line.getWidth())</code></pre></dd>
        <dt>should have the type property of &quot;Line&quot;</dt>
        <dd><pre><code>lineSpec.type.should.equal(&quot;Line&quot;)</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from Shape</h1>
      <dl>
        <section class="suite">
          <h1>#setCentre</h1>
          <dl>
            <dt>should have an x coordinate of 1</dt>
            <dd><pre><code>shape.getCentre().getX().getValue().should.equal(centreX)</code></pre></dd>
            <dt>should have a y coordinate of 2</dt>
            <dd><pre><code>shape.getCentre().getY().getValue().should.equal(centreY)</code></pre></dd>
            <dt>should have a z coordinate of 3</dt>
            <dd><pre><code>shape.getCentre().getZ().getValue().should.equal(centreZ)</code></pre></dd>
            <dt>should not have exactly the same Point as its centre</dt>
            <dd><pre><code>shape.getCentre().should.not.equal(point)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>distance to boundary functions</h1>
          <dl>
            <section class="suite">
              <h1>#getDistanceToRightBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToRightBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToLeftBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToLeftBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToFrontBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToFrontBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToBackBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToBackBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#isAdjacentTo</h1>
          <dl>
            <dt>should return false if the Circle is not touching the Shape</dt>
            <dd><pre><code>point.setAt(centreX - 100, centreY, centreZ)
circle.setCentre(point)
shape.isAdjacentTo(circle).should.be.false</code></pre></dd>
            <dt>should return true if the Circle is to it's left</dt>
            <dd><pre><code>point.setAt(centreX - 1, centreY, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
            <dt>should return true if the Circle is to it's right</dt>
            <dd><pre><code>point.setAt(centreX + 1, centreY, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
            <dt>should return true if the Circle is to it's front</dt>
            <dd><pre><code>point.setAt(centreX, centreY + 1, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
            <dt>should return true if the Circle is to it's back</dt>
            <dd><pre><code>point.setAt(centreX, centreY - 1, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>ComponentSpecification</h1>
      <dl>
        <dt>should behave like a Specification</dt>
        <dd><pre><code>SpecificationTest.shouldBehaveLikeSpecification(componentSpec)</code></pre></dd>
        <section class="suite">
          <h1>#centreX</h1>
          <dl>
            <dt>should have the correct value</dt>
            <dd><pre><code>componentSpec.centreX.should.equal(centre.getX().getValue())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#centreY</h1>
          <dl>
            <dt>should have the correct value</dt>
            <dd><pre><code>componentSpec.centreY.should.equal(centre.getY().getValue())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#centreZ</h1>
          <dl>
            <dt>should have the correct value</dt>
            <dd><pre><code>componentSpec.centreZ.should.equal(centre.getZ().getValue())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#type</h1>
          <dl>
            <dt>should have the correct value</dt>
            <dd><pre><code>componentSpec.type.should.equal(component.getTypeName())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#id</h1>
          <dl>
            <dt>should have the same value as the ID of the Component</dt>
            <dd><pre><code>componentSpec.id.should.equal(component.getID())</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from Component</h1>
      <dl>
        <section class="suite">
          <h1>#getBoundingShape</h1>
          <dl>
            <dt>should return a Shape</dt>
            <dd><pre><code>ShapeTest.shouldBehaveLikeShape(component.getBoundingShape())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#getCentre</h1>
          <dl>
            <dt>should return a Point</dt>
            <dd><pre><code>component.getCentre().should.be.an.instanceOf(Point)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#setCentre</h1>
          <dl>
            <dt>should set the centre of the Component to have the same coordinates as the passed-in Point</dt>
            <dd><pre><code>component.getCentre().isAtSameLocationAs(point).should.be.true</code></pre></dd>
            <dt>should not have exactly the same Point as its centre</dt>
            <dd><pre><code>component.getCentre().should.not.equal(point)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#toString</h1>
          <dl>
            <dt>should return a string</dt>
            <dd><pre><code>component.toString().should.be.type('string')</code></pre></dd>
            <section class="suite">
              <h1>the returned string</h1>
              <dl>
                <dt>should contain the id</dt>
                <dd><pre><code>string.should.contain('ID: ' + id)</code></pre></dd>
                <dt>should contain the centre point</dt>
                <dd><pre><code>string.should.contain('Centre point: (' + centreX + ', ' + centreY 
	                    + ', ' + centreZ + ')')</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#toSpecification</h1>
          <dl>
            <dt>should not be possible if the centre Point is not fully defined</dt>
            <dd><pre><code>component.toSpecification.should.throw()</code></pre></dd>
            <dt>should be possible if the centre Point is fully defined </dt>
            <dd><pre><code>(function() {
							fixCentre()
							component.toSpecification()
						}).should.not.throw()</code></pre></dd>
            <section class="suite">
              <h1>the returned ComponentSpecification</h1>
              <dl>
                <dt>should behave like a ComponentSpecification derived from the Component</dt>
                <dd><pre><code>ComponentSpecificationTest.testComponentSpecification(componentSpec,
	                                                    component)</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from Shape</h1>
      <dl>
        <section class="suite">
          <h1>#setCentre</h1>
          <dl>
            <dt>should have an x coordinate of 1</dt>
            <dd><pre><code>shape.getCentre().getX().getValue().should.equal(centreX)</code></pre></dd>
            <dt>should have a y coordinate of 2</dt>
            <dd><pre><code>shape.getCentre().getY().getValue().should.equal(centreY)</code></pre></dd>
            <dt>should have a z coordinate of 3</dt>
            <dd><pre><code>shape.getCentre().getZ().getValue().should.equal(centreZ)</code></pre></dd>
            <dt>should not have exactly the same Point as its centre</dt>
            <dd><pre><code>shape.getCentre().should.not.equal(point)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>distance to boundary functions</h1>
          <dl>
            <section class="suite">
              <h1>#getDistanceToRightBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToRightBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToLeftBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToLeftBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToFrontBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToFrontBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToBackBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToBackBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#isAdjacentTo</h1>
          <dl>
            <dt>should return false if the Circle is not touching the Shape</dt>
            <dd><pre><code>point.setAt(centreX - 100, centreY, centreZ)
circle.setCentre(point)
shape.isAdjacentTo(circle).should.be.false</code></pre></dd>
            <dt>should return true if the Circle is to it's left</dt>
            <dd><pre><code>point.setAt(centreX - 1, centreY, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
            <dt>should return true if the Circle is to it's right</dt>
            <dd><pre><code>point.setAt(centreX + 1, centreY, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
            <dt>should return true if the Circle is to it's front</dt>
            <dd><pre><code>point.setAt(centreX, centreY + 1, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
            <dt>should return true if the Circle is to it's back</dt>
            <dd><pre><code>point.setAt(centreX, centreY - 1, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from Specification</h1>
      <dl>
        <section class="suite">
          <h1>#addSpecification</h1>
          <dl>
            <dt>should have the same properties as the added Specification</dt>
            <dd><pre><code>specification.should.have.property('secondTestProperty', 'second')</code></pre></dd>
            <dt>should still have its original properties</dt>
            <dd><pre><code>specification.should.have.property('firstTestProperty', 'first')</code></pre></dd>
            <section class="suite">
              <h1>when the added Specification has the same property as the original property but with a different value</h1>
              <dl>
                <dt>should use the added Specification's value</dt>
                <dd><pre><code>specification.firstTestProperty.should.equal('different')</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from Specification</h1>
      <dl>
        <section class="suite">
          <h1>#addSpecification</h1>
          <dl>
            <dt>should have the same properties as the added Specification</dt>
            <dd><pre><code>specification.should.have.property('secondTestProperty', 'second')</code></pre></dd>
            <dt>should still have its original properties</dt>
            <dd><pre><code>specification.should.have.property('firstTestProperty', 'first')</code></pre></dd>
            <section class="suite">
              <h1>when the added Specification has the same property as the original property but with a different value</h1>
              <dl>
                <dt>should use the added Specification's value</dt>
                <dd><pre><code>specification.firstTestProperty.should.equal('different')</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from Specification</h1>
      <dl>
        <section class="suite">
          <h1>#addSpecification</h1>
          <dl>
            <dt>should have the same properties as the added Specification</dt>
            <dd><pre><code>specification.should.have.property('secondTestProperty', 'second')</code></pre></dd>
            <dt>should still have its original properties</dt>
            <dd><pre><code>specification.should.have.property('firstTestProperty', 'first')</code></pre></dd>
            <section class="suite">
              <h1>when the added Specification has the same property as the original property but with a different value</h1>
              <dl>
                <dt>should use the added Specification's value</dt>
                <dd><pre><code>specification.firstTestProperty.should.equal('different')</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from Shape</h1>
      <dl>
        <section class="suite">
          <h1>#setCentre</h1>
          <dl>
            <dt>should have an x coordinate of 1</dt>
            <dd><pre><code>shape.getCentre().getX().getValue().should.equal(centreX)</code></pre></dd>
            <dt>should have a y coordinate of 2</dt>
            <dd><pre><code>shape.getCentre().getY().getValue().should.equal(centreY)</code></pre></dd>
            <dt>should have a z coordinate of 3</dt>
            <dd><pre><code>shape.getCentre().getZ().getValue().should.equal(centreZ)</code></pre></dd>
            <dt>should not have exactly the same Point as its centre</dt>
            <dd><pre><code>shape.getCentre().should.not.equal(point)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>distance to boundary functions</h1>
          <dl>
            <section class="suite">
              <h1>#getDistanceToRightBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToRightBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToLeftBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToLeftBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToFrontBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToFrontBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getDistanceToBackBoundary</h1>
              <dl>
                <dt>should return a number</dt>
                <dd><pre><code>shape.getDistanceToBackBoundary().should.be.a.Number</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#isAdjacentTo</h1>
          <dl>
            <dt>should return false if the Circle is not touching the Shape</dt>
            <dd><pre><code>point.setAt(centreX - 100, centreY, centreZ)
circle.setCentre(point)
shape.isAdjacentTo(circle).should.be.false</code></pre></dd>
            <dt>should return true if the Circle is to it's left</dt>
            <dd><pre><code>point.setAt(centreX - 1, centreY, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
            <dt>should return true if the Circle is to it's right</dt>
            <dd><pre><code>point.setAt(centreX + 1, centreY, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
            <dt>should return true if the Circle is to it's front</dt>
            <dd><pre><code>point.setAt(centreX, centreY + 1, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
            <dt>should return true if the Circle is to it's back</dt>
            <dd><pre><code>point.setAt(centreX, centreY - 1, centreZ)
					circle.setCentre(point)
					shape.isAdjacentTo(circle).should.be.true</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>ComponentSpecification</h1>
      <dl>
        <dt>should behave like a Specification</dt>
        <dd><pre><code>SpecificationTest.shouldBehaveLikeSpecification(componentSpec)</code></pre></dd>
        <section class="suite">
          <h1>#centreX</h1>
          <dl>
            <dt>should have the correct value</dt>
            <dd><pre><code>componentSpec.centreX.should.equal(centre.getX().getValue())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#centreY</h1>
          <dl>
            <dt>should have the correct value</dt>
            <dd><pre><code>componentSpec.centreY.should.equal(centre.getY().getValue())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#centreZ</h1>
          <dl>
            <dt>should have the correct value</dt>
            <dd><pre><code>componentSpec.centreZ.should.equal(centre.getZ().getValue())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#type</h1>
          <dl>
            <dt>should have the correct value</dt>
            <dd><pre><code>componentSpec.type.should.equal(component.getTypeName())</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#id</h1>
          <dl>
            <dt>should have the same value as the ID of the Component</dt>
            <dd><pre><code>componentSpec.id.should.equal(component.getID())</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Anything inheriting from Specification</h1>
      <dl>
        <section class="suite">
          <h1>#addSpecification</h1>
          <dl>
            <dt>should have the same properties as the added Specification</dt>
            <dd><pre><code>specification.should.have.property('secondTestProperty', 'second')</code></pre></dd>
            <dt>should still have its original properties</dt>
            <dd><pre><code>specification.should.have.property('firstTestProperty', 'first')</code></pre></dd>
            <section class="suite">
              <h1>when the added Specification has the same property as the original property but with a different value</h1>
              <dl>
                <dt>should use the added Specification's value</dt>
                <dd><pre><code>specification.firstTestProperty.should.equal('different')</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>

</div></body>